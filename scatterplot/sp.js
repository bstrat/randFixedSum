// Generated by CoffeeScript 1.6.3
var addLabel, addLines, animate, animating, camera, createText2D, createTextCanvas, down, h, i, j, k, last, newVertex, onmessage, p, paused, pointCount, pointGeo, points, q, r, renderer, rfs, rs, s, scatterPlot, scene, sx, sy, transForm, vs, vx, w, x, y, z, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4,
  __slice = [].slice;

createTextCanvas = function(text, color, font, size) {
  var ctx, cvs;
  if (color == null) {
    color = 'black';
  }
  if (font == null) {
    font = 'Tahoma';
  }
  if (size == null) {
    size = 20;
  }
  cvs = document.createElement('canvas');
  ctx = cvs.getContext('2d');
  ctx.font = "" + size + "px " + font;
  cvs.width = ctx.measureText(text).width;
  cvs.height = Math.ceil(size);
  ctx.font = "" + size + "px " + font;
  ctx.fillStyle = color;
  ctx.fillText(text, 0, Math.ceil(size * 0.8));
  return cvs;
};

createText2D = function(text, color, font, size, segW, segH) {
  var cvs, msh, tex;
  cvs = createTextCanvas(text, color, font, size);
  tex = new THREE.Texture(cvs);
  tex.needsUpdate = true;
  msh = new THREE.Mesh(new THREE.PlaneGeometry(cvs.width, cvs.height, segW, segH), new THREE.MeshBasicMaterial({
    map: tex,
    color: 0xffffff,
    transparent: true
  }));
  msh.scale.set(0.25, 0.25, 0.25);
  msh.doubleSided = true;
  return msh;
};

renderer = new THREE.WebGLRenderer({
  antialias: true
});

w = window.innerWidth;

h = window.innerHeight;

renderer.setSize(w, h);

document.body.appendChild(renderer.domElement);

renderer.setClearColorHex(0xffffff, 1.0);

camera = new THREE.PerspectiveCamera(45, w / h, 1, 10000);

camera.position.z = 220;

camera.position.x = 0;

camera.position.y = 15;

scene = new THREE.Scene();

scene.fog = new THREE.FogExp2(0xffffff, 0.0035);

scatterPlot = new THREE.Object3D();

scene.add(scatterPlot);

scatterPlot.rotation.y = 0.5;

transForm = function(x, y, z) {
  return [100 * (x - 0.5), 100 * (y - 0.5), 100 * (0.5 - z)];
};

newVertex = function(x, y, z) {
  return new THREE.Vertex((function(func, args, ctor) {
    ctor.prototype = func.prototype;
    var child = new ctor, result = func.apply(child, args);
    return Object(result) === result ? result : child;
  })(THREE.Vector3, transForm(x, y, z), function(){}));
};

addLines = function(vs, c, lw, o3d) {
  var line, lineGeo, vx, _i, _len;
  if (c == null) {
    c = 0x000000;
  }
  if (lw == null) {
    lw = 1;
  }
  if (o3d == null) {
    o3d = scatterPlot;
  }
  lineGeo = new THREE.Geometry();
  for (_i = 0, _len = vs.length; _i < _len; _i++) {
    vx = vs[_i];
    lineGeo.vertices.push(newVertex.apply(null, vx));
  }
  line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({
    color: c,
    lineWidth: lw
  }));
  line.type = THREE.Lines;
  return o3d.add(line);
};

addLabel = function(l, x, y, z, r, o3d) {
  var l2d, _ref;
  if (r == null) {
    r = 0;
  }
  if (o3d == null) {
    o3d = scatterPlot;
  }
  l2d = createText2D(l);
  _ref = transForm(x, y, z), l2d.position.x = _ref[0], l2d.position.y = _ref[1], l2d.position.z = _ref[2];
  l2d.rotation.y = -Math.PI * r;
  return o3d.add(l2d);
};

vs = [];

_ref = [[0, 0, 0], [0, 1, 1], [1, 0, 1], [1, 1, 0]];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  p = _ref[_i];
  for (i = _j = 0; _j <= 2; i = ++_j) {
    q = p.slice(0);
    q[i] = (p[i] + 1) % 2;
    _ref1 = [p, q];
    for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
      vx = _ref1[_k];
      vs.push(vx);
    }
  }
}

for (i = _l = 0; _l <= 2; i = ++_l) {
  _ref2 = [[i / 2, 0, -0.05], [1.02, i / 2, 0], [-0.05, 0, i / 2]];
  for (j = _m = 0, _len2 = _ref2.length; _m < _len2; j = ++_m) {
    p = _ref2[j];
    q = p.slice(0);
    k = j === 0 ? 2 : 0;
    q[k] += 0.03;
    _ref3 = [p, q];
    for (_n = 0, _len3 = _ref3.length; _n < _len3; _n++) {
      vx = _ref3[_n];
      vs.push(vx);
    }
    r = p.slice(0);
    r[k] = r[k] > 1 ? 1.1 : -0.1;
    addLabel.apply(null, [(i / 2).toString()].concat(__slice.call(r), [j === 0 ? 0.5 : 0]));
  }
}

addLines(vs, 0x808080);

s = 1.25;

vs = [];

for (i = _o = 0; _o <= 2; i = ++_o) {
  for (k = _p = 0; _p <= 1; k = ++_p) {
    for (j = _q = 0; _q <= 2; j = ++_q) {
      if (!(j !== i)) {
        continue;
      }
      p = [s - 1, s - 1, s - 1];
      p[i] = k;
      p[j] = 1 - k;
      vs.push(p);
    }
  }
}

addLines(vs);

pointCount = 16384;

pointGeo = new THREE.Geometry();

rfs = randFixedSum(3, pointCount, s, 0, 1);

for (i = _r = 0, _len4 = rfs.length; _r < _len4; i = ++_r) {
  rs = rfs[i];
  _ref4 = transForm.apply(null, rs), x = _ref4[0], y = _ref4[1], z = _ref4[2];
  pointGeo.vertices.push(new THREE.Vertex(new THREE.Vector3(x, y, z)));
  pointGeo.vertices[i].angle = Math.atan2(z, x);
  pointGeo.vertices[i].radius = Math.sqrt(x * x + z * z);
  pointGeo.vertices[i].speed = (z / 100) * (x / 100);
  pointGeo.colors.push(new THREE.Color().setHSV((x + 50) / 100, (z + 50) / 100, (y + 50) / 100));
}

points = new THREE.ParticleSystem(pointGeo, new THREE.ParticleBasicMaterial({
  vertexColors: true,
  size: 1.0
}));

scatterPlot.add(points);

renderer.render(scene, camera);

paused = false;

last = new Date().getTime();

down = false;

sx = 0;

sy = 0;

window.onmousedown = function(ev) {
  down = true;
  sx = ev.clientX;
  return sy = ev.clientY;
};

window.onmouseup = function() {
  return down = false;
};

window.onmousemove = function(ev) {
  var dx, dy;
  if (down) {
    dx = ev.clientX - sx;
    dy = ev.clientY - sy;
    scatterPlot.rotation.y += dx * 0.01;
    camera.position.y += dy;
    sx += dx;
    return sy += dy;
  }
};

animating = false;

window.ondblclick = function() {
  return animating = !animating;
};

animate = function(t) {
  var u, _len5, _ref5, _s;
  if (!paused) {
    last = t;
    if (animating) {
      _ref5 = pointGeo.vertices;
      for (_s = 0, _len5 = _ref5.length; _s < _len5; _s++) {
        u = _ref5[_s];
        u.angle += u.speed * 0.01;
        u.position.x = Math.cos(u.angle) * u.radius;
        u.position.z = Math.sin(u.angle) * u.radius;
      }
      pointGeo.__dirtyVertices = true;
    }
    renderer.clear();
    camera.lookAt(scene.position);
    renderer.render(scene, camera);
  }
  return window.requestAnimationFrame(animate, renderer.domElement);
};

animate(new Date().getTime());

onmessage = function(ev) {
  return paused = ev.data === 'pause';
};
